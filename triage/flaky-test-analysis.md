**Flaky Test Analysis: CI vs. Local Environment**



**Investigation Steps**

**1.Analyze Execution Artifacts**: Review video recordings and screenshots generated by the CI runner to identify exactly where the UI state diverged from expectations.

**2.Examine CI Network Logs**: Check for latency or failures in API responses (Order/Payment) that might not occur on the faster, more stable local network.

**3.Compare Resource Constraints**: Verify if the CI environment has sufficient CPU/Memory, as resource starvation often causes "race conditions" where the code executes faster than the UI can render.

**4.Inspect Database State**: Check the SQL database for data "pollution" from previous runs, ensuring a fresh state is used for every test execution.



**Reasoning \& Solutions**

\-**Asynchronous Waiting**: I avoid "Hard Sleeps" (static waits) and instead use dynamic assertions (e.g., `should('be.visible')`) to handle timing differences between CI and Local.

\-**Network Isolation**: By using mocks (`cy.intercept`), we remove the risk of intermittent failures caused by external third-party payment gateways.

